<a name="1"></a>

### 1. 连nil切片和空切片一不一样都不清楚？那BAT面试官只好让你回去等通知了。

#### nil切片

* 【定义】未经初始化的切片。通常通过声明如`var s []int`来创建。
* 【内存分配】不占用内存空间。长度和容量都是0。
* 【底层指针】底层指针指向nil

#### 空切片

* 【定义】已初始化但没有包含任何元素的切片。
可通过`var s []int = []int{}或s := make([]int, 0)`创建。
* 【内存分配】占用内存空间，但长度和容量为0。底层指向一个分配了内存但当前没有元素的数组
* 【底层指针】底层指针指向一个空的数组

<a name="2"></a>

### 2. 字符串转成byte数组，会发生内存拷贝吗？

> 会的。Go中的字符串是不可变的，而字节切片是可变的

当执行 `b := []byte(s)` 这样的操作时，Go会创建一个新的字节切片 `b` 并将字符串 `s` 中的所有字节复制到 `b` 中。这样做是为了确保字符串的不可变性，以及在修改字节切片时不会影响原始字符串。

### [3. golang面试题：翻转含有中文、数字、英文字母的字符串](#3)

> 这里的坑在于中文字符在UTF-8编码中占据多个字节，因此不能像ASCII字符那样单字节处理。
> 
> 有效的方法是将字符串转换成 `rune` 切片，然后再翻转这个切片， `rune`数据类型在go中代表单个Unicode字符。

```go
package main

import "fmt"

func reverseString(s string) string {
    runes := []rune(s)
    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
        runes[i], runes[j] = runes[j], runes[i]
    }
    return string(runes)
}

func main() {
    str := "Hello, 世界123"
    reversed := reverseString(str)
    fmt.Println("Original:", str)
    fmt.Println("Reversed:", reversed)
}
```



### [4. golang面试题：拷贝大切片一定比小切片代价大吗？](#4)

> 这里分两种情况。一种是拷贝切片结构，另一种是拷贝切片数据。

#### 拷贝切片结构

如果仅仅是拷贝切片结构，如 `newSlice := oldSlice`。那么确实如 [小白大佬这篇文章](https://mp.weixin.qq.com/s/VaM4yJXHYyDyRY0XHIyhpQ) 所说，代价是一样的。因为无论是大切片还是小切片，它的底层结构本质还是三个字段：**一个指向数组起始位置的指针、切片的长度和切片的容量**。

#### 拷贝切片数据

如果是拷贝切片数据，如 `copy(newSlice, oldSlice)`，这样就是拷贝切片中数据到全新的切片了。在这种情况下，拷贝的代价与元素数量有关，更多的元素意味着更长的拷贝时间和更多的内存使用。



### [5. map不初始化使用会怎么样](#5)

声明但不初始化一个map，它的默认值是nil。就像这样 `var myMap map[string]int`

* 当尝试往这个map添加元素，如 `myMap["key"] = 123` 运行时会panic
* 当尝试获取这个map的值，如 `value := myMap["key"]` 返回的是元素类型的零值，如0。
* 当用语法 `value, ok := myMap["key"]` 检查map时，ok会是false



### [6. map不初始化长度和初始化长度的区别](#6)

#### 未初始化长度的map

* map在初始化可以不定义长度，如`m := make(map[string]int)`
* go根据map的使用情况动态调整大小。在map大量增长时，会导致额外的内存分配和性能开销。
* 【应用场景】元素较少，不确定长度可用

#### 初始化长度的map

* map在初始化的时候定义长度，如 `m := make(map[string]int, 100)`
* go会根据初始化定义的长度开辟对应大小的内存空间，可以减少内存分配。但不合理的长度也会造成内存浪费
* 【应用场景】元素较多，且能估算大小范围



### [7.  map承载多大，大了怎么办](#7)

#### map承载多大

map最大容量受限于两个因素：地址空间和内存空间

* 地址空间。32位系统，理论上可以容纳4GB的数据。64位系统，理论可以达到数百万TB，这在实际应用几乎不可能达到。
* 内存空间。**实际上，map的大小更多是受限于机器的可用内存。**

#### 大了怎么办

1. 【优化使用】如果有结构化特征，用结构体代替；对于大的数据集，考虑使用数据库
2. 【分片】根据合适的分片策略将一个大的map分成多个小的map，提高单个map的访问效率
3. 【内存扩容】机器加内存
4. 【数据清理】定期将不需要的map项清理



### [8. map的iterator是否安全？能不能一边delete一边遍历？](#8)

#### map的iterator是否安全

iterator是迭代器，一般情况下，在不修改map，迭代器是安全的。

**在并发场景下，map不是安全的。即使是仅读取也是如此。需要增加读写锁来确保安全**



#### 能否边删除边遍历

1. 如果删除当前键是安全的。
2. **如果遍历时删除其他键会导致迭代器的行为不可预测。**



### [9. 字符串不能改，那转成数组能改吗，怎么改](#9)

* 转换成rune数组。一个`rune`代表一个UTF-8字符串，适用于多字节字符。

```go
package main

import "fmt"

func main() {
    str := "hello, 世界"
    runes := []rune(str)

    // 修改第一个字符
    runes[0] = 'H'

    // 修改一个中文字符
    runes[7] = '中'

    // 将rune数组转回字符串
    modifiedStr := string(runes)
    fmt.Println(modifiedStr)
}
```



* 转换成byte数组。一个 `byte` 代表一个ASCII字符，适用于单字节字符。

```go
package main

import "fmt"

func main() {
    str := "hello"
    bytes := []byte(str)

    // 修改第一个字符
    bytes[0] = 'H'

    // 将byte数组转回字符串
    modifiedStr := string(bytes)
    fmt.Println(modifiedStr)
}
```





### [10. 怎么判断一个数组是否已经排序](#10)

>  使用标准库中的 `sort`  包提供的函数

* 整数切片。用 `IntsAreSorted`
* 浮点数切片。用 `Float64sAreSorted`
* 字符串切片。用 `StringsAreSorted`
* 自定类型。实现 `sort.Interface`，然后使用 `sort.IsSorted` 函数



### [11. 普通map如何不用锁解决协程安全问题](#11)

使用channel，将map的操作都限制在一个单独的协程中。

```go
package main

import (
	"fmt"
	"sync"
)

// 定义操作类型
type operation int

const (
	opRead operation = iota
	opWrite
	opDelete
)

// 请求结构体
type request struct {
	op      operation
	key     string
	value   interface{}
	respChan chan interface{}
}

func mapManager(requests chan request) {
	m := make(map[string]interface{})

	for req := range requests {
		switch req.op {
		case opRead:
			req.respChan <- m[req.key]
		case opWrite:
			m[req.key] = req.value
			req.respChan <- nil
		case opDelete:
			delete(m, req.key)
			req.respChan <- nil
		}
	}
}

func main() {
	requests := make(chan request)
	go mapManager(requests)

	respChan := make(chan interface{})

	// 写入数据
	requests <- request{op: opWrite, key: "hello", value: "world", respChan: respChan}
	<-respChan // 等待写操作完成

	// 读取数据
	requests <- request{op: opRead, key: "hello", respChan: respChan}
	value := <-respChan
	fmt.Println("Read:", value)

	// 删除数据
	requests <- request{op: opDelete, key: "hello", respChan: respChan}
	<-respChan // 等待删除操作完成
}
```



### [12. array和slice的区别](#12)

#### array

1. 【固定长度】数组的长度在定义时确定而不能改变
2. 【值类型】数组是值类型，当赋值给另一个变量时，会复制整个数组
3. 【内存分配】数组通常分配在栈上，除非作为全局变量或者指针才会分配到堆上

#### slice

1. 【可变长度】切片的长度是动态的
2. 【引用类型】切片是引用类型，当赋值给另一个变量时，两个变量用的是同一个底层数组
3. 【内存分配】切片本身（指向数组起始位置指针、长度、容量三部分）分配在栈上，但指向的元素存储在堆上



### [13. golang面试题：json包变量不加tag会怎么样？](#13)

1. 如果字段是非导出字段，加不加tag都一样，序列化和反序列化都会被忽略
2. 如果字段是导出字段
   * 不加tag，序列化和反序列化会使用字段实际名称作为json的键
   * 不加tag无法控制一些特殊行为：忽略空值字段、指定字段为可选等

### [14. golang面试题：reflect（反射包）如何获取字段tag？为什么json包不能导出私有变量的tag？](#14)

#### 如何获取tag

```go
package main

import (
    "fmt"
    "reflect"
)

type Sample struct {
    Field1 string `json:"field1"`
    Field2 int    `json:"field2"`
}

func main() {
    s := Sample{}
    t := reflect.TypeOf(s)
    for i := 0; i < t.NumField(); i++ {
        field := t.Field(i)
        fmt.Printf("Field: %s, Tag: '%s'\n", field.Name, field.Tag.Get("json"))
    }
}

```

#### 为什么json包不能导出私有变量的tag

* 在go中，非导出字段对于包外不可见，是go访问控制的一部分。

* 私有字段的标签对于json包不可见，因此json包无法访问这些标签



<a name="15"></a>

### 15. 零切片、空切片、nil切片是什么

#### 零切片

* 不是官方术语，字面意思是切片类型的零值，通常指的就是nil切片

#### 空切片

* 已经初始化的切片，长度和容量都是0
* 底层指向空的，已经分配内存的数组

#### nil切片

* 没有分配内存的切片，长度和容量都是0
* 尝试访问会报错



### [16. slice深拷贝和浅拷贝](#16)

#### 深拷贝

* 【概念】指的是复制原切片到一个新的独立的底层数组中。
* 【表现】两个切片完全独立，如果修改一个切片，另外一个不受改变

```go
original := []int{1, 2, 3}
copy := make([]int, len(original))
copy(copy, original) // 这是深拷贝
copy[0] = 100
fmt.Println(original) // 输出 [1 2 3]
```

#### 浅拷贝

* 【概念】指的是复制切片的引用，而不复制切片的数据。
* 【表现】两个切片共享一个底层数组，如果修改一个切片，另外一个也会修改

```go
original := []int{1, 2, 3}
copy := original // 这是浅拷贝
copy[0] = 100
fmt.Println(original) // 输出 [100 2 3]
```



### [17. map触发扩容的时机，满足什么条件时扩容？](#17)

> 装载因子：map中已填充条目数与其容量的比率。
>
> 散列冲突：由于哈希键值的长度是固定的，因此它的可能值是固定的。但是键的可能值远多于哈希键值大小，那么必然会出现散列冲突（哈希冲突）

* 当装载因子达到0.65，map会触发 `双倍扩容`。
  * 达到0.65，预示着存储快满了，因此需要翻倍容量
* 当出现过多的散列冲突时，即使元素数量没有达到扩容阈值，也会触发 `等量扩容`。
  * 等量扩容解决的是散列分布不均，使元素重新排列得更加紧密

### [18. map扩容策略是什么](#18)

#### 触发条件

* 当装载因子达到0.65，map会触发 `双倍扩容`。
* 当出现过多的散列冲突时，即使元素数量没有达到扩容阈值，也会触发 `等量扩容`。

#### 扩容的过程

* 逐步扩容。map扩容过程是渐进式的，当map为标识正在扩容状态，每次写操作都会操作一小部分扩容动作

### [19. 自定义类型切片转字节切片和字节切片转回自动以类型切片](#19)
### [20. make和new什么区别](#20)
### [21. slice ，map，chanel创建的时候的几个参数什么含义](#21)
### [22. slice，len，cap，共享，扩容](#22)
### [23. 线程安全的map怎么实现](#23)
### [24. go slice 和 array 区别](#24)
### [25. go struct能不能比较？](#25)
### [26. map如何顺序读取？](#26)
### [27. go中怎么实现set](#27)
### [28. map 的扩容机制是什么？](#28)
### [29. 使用值为 nil 的 sice、map 会发生什么？](#29)
### [30. Golang 有没有 this 指针？](#30)
### [31. Golang 语言中局部变量和全局变量的缺省值是什么](#31)
### [32. Golang 中的引用类型包含哪些?](#32)
### [33. 使用range 迭代 map 是有序的吗?](#33)
### [34. slice 的扩容机制是什么？](#34)
### [35. Golang 中指针运算有哪些?](#35)
### [36. 类型的值可以修改吗？](#6)
### [37. 解析 JSON 数据时，默认将数值当做哪种类型](#37)
### [38. array 类型的值作为函数参数是引用传递还是值传递？](#38)