### [1.连nil切片和空切片一不一样都不清楚？那BAT面试官只好让你回去等通知了。](#1)

#### nil切片

* 【定义】未经初始化的切片。通常通过声明如`var s []int`来创建。
* 【内存分配】不占用内存空间。长度和容量都是0。
* 【底层指针】底层指针指向nil

#### 空切片

* 【定义】已初始化但没有包含任何元素的切片。
可通过`var s []int = []int{}或s := make([]int, 0)`创建。
* 【内存分配】占用内存空间，但长度和容量为0。底层指向一个分配了内存但当前没有元素的数组
* 【底层指针】底层指针指向一个空的数组

### [2. 字符串转成byte数组，会发生内存拷贝吗？](#2)

> 会的。Go中的字符串是不可变的，而字节切片是可变的

当执行 `b := []byte(s)` 这样的操作时，Go会创建一个新的字节切片 `b` 并将字符串 `s` 中的所有字节复制到 `b` 中。这样做是为了确保字符串的不可变性，以及在修改字节切片时不会影响原始字符串。

### [3. golang面试题：翻转含有中文、数字、英文字母的字符串](#3)

> 这里的坑在于中文字符在UTF-8编码中占据多个字节，因此不能像ASCII字符那样单字节处理。
> 
> 有效的方法是将字符串转换成 `rune` 切片，然后再翻转这个切片， `rune`数据类型在go中代表单个Unicode字符。

```go
package main

import "fmt"

func reverseString(s string) string {
    runes := []rune(s)
    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
        runes[i], runes[j] = runes[j], runes[i]
    }
    return string(runes)
}

func main() {
    str := "Hello, 世界123"
    reversed := reverseString(str)
    fmt.Println("Original:", str)
    fmt.Println("Reversed:", reversed)
}
```



### [4. golang面试题：拷贝大切片一定比小切片代价大吗？](#4)

> 这里分两种情况。一种是拷贝切片结构，另一种是拷贝切片数据。

#### 拷贝切片结构

如果仅仅是拷贝切片结构，如 `newSlice := oldSlice`。那么确实如 [小白大佬这篇文章](https://mp.weixin.qq.com/s/VaM4yJXHYyDyRY0XHIyhpQ) 所说，代价是一样的。因为无论是大切片还是小切片，它的底层结构本质还是三个字段：**一个指向数组起始位置的指针、切片的长度和切片的容量**。

#### 拷贝切片数据

如果是拷贝切片数据，如 `copy(newSlice, oldSlice)`，这样就是拷贝切片中数据到全新的切片了。在这种情况下，拷贝的代价与元素数量有关，更多的元素意味着更长的拷贝时间和更多的内存使用。



### [5. map不初始化使用会怎么样](#5)

声明但不初始化一个map，它的默认值是nil。就像这样 `var myMap map[string]int`

* 当尝试往这个map添加元素，如 `myMap["key"] = 123` 运行时会panic
* 当尝试获取这个map的值，如 `value := myMap["key"]` 返回的是元素类型的零值，如0。
* 当用语法 `value, ok := myMap["key"]` 检查map时，ok会是false



### [6. map不初始化长度和初始化长度的区别](#6)

#### 未初始化长度的map

* map在初始化可以不定义长度，如`m := make(map[string]int)`
* go根据map的使用情况动态调整大小。在map大量增长时，会导致额外的内存分配和性能开销。
* 【应用场景】元素较少，不确定长度可用

#### 初始化长度的map

* map在初始化的时候定义长度，如 `m := make(map[string]int, 100)`
* go会根据初始化定义的长度开辟对应大小的内存空间，可以减少内存分配。但不合理的长度也会造成内存浪费
* 【应用场景】元素较多，且能估算大小范围



### [7.  map承载多大，大了怎么办](#7)
### [8. map的iterator是否安全？能不能一边delete一边遍历？](#8)
### [9. 字符串不能改，那转成数组能改吗，怎么改](#9)
### [10. 怎么判断一个数组是否已经排序](#10)
### [11. 普通map如何不用锁解决协程安全问题](#11)
### [12. array和slice的区别](#12)
### [13. golang面试题：json包变量不加tag会怎么样？](#13)
### [14. golang面试题：reflect（反射包）如何获取字段tag？为什么json包不能导出私有变量的tag？](#14)
### [15. 零切片、空切片、nil切片是什么](#15)
### [16. slice深拷贝和浅拷贝](#16)
### [17. map触发扩容的时机，满足什么条件时扩容？](#17)
### [18. map扩容策略是什么](#18)
### [19. 自定义类型切片转字节切片和字节切片转回自动以类型切片](#19)
### [20. make和new什么区别](#20)
### [21. lice ，map，chanel创建的时候的几个参数什么含义](#21)
### [22. lice，len，cap，共享，扩容](#22)
### [23. 线程安全的map怎么实现](#23)
### [24. go slice 和 array 区别](#24)
### [25. go struct能不能比较？](#25)
### [26. map如何顺序读取？](#26)
### [27. go中怎么实现set](#27)
### [28. map 的扩容机制是什么？](#28)
### [29. 使用值为 nil 的 sice、map 会发生什么？](#29)
### [30. Golang 有没有 this 指针？](#30)
### [31. Golang 语言中局部变量和全局变量的缺省值是什么](#31)
### [32. Golang 中的引用类型包含哪些?](#32)
### [33. 使用range 迭代 map 是有序的吗?](#33)
### [34. slice 的扩容机制是什么？](#34)
### [35. Golang 中指针运算有哪些?](#35)
### [36. 类型的值可以修改吗？](#6)
### [37. 解析 JSON 数据时，默认将数值当做哪种类型](#37)
### [38. array 类型的值作为函数参数是引用传递还是值传递？](#38)